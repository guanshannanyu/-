DATAS SEGMENT
mode  dw 0
COLOR DW 12
BKCOLOR DW 15
POINT dw 160,200,480,200,480,200,220,380
      dw 220,380,320,80,320,80,420,380
      dw 420,380,160,200
DATAS ENDS

STACKS SEGMENT
DW 200 DUP(0)
STACKS ENDS

CODES SEGMENT
ASSUME CS:CODES,DS:DATAS,SS:STACKS
START:
   mov dx,datas
   mov ds,ax
   mov ah,0fh
   int 10h
   mov ah,0
   mov mode,ax;保存原显示模式
   MOV AX,0012H
   INT 10H ;设置640*480*16图形模式
   nop
Q6:MOV AX,DATAS
MOV DS,AX
MOV AX,0A000H
MOV ES,AX
MOV AL,2
CALL SET_WRITE_MODE
MOV AX,BKCOLOR
CALL CLEAR
MOV CX,5
MOV SI,OFFSET POINT
DDD: PUSH CX
PUSH SI
MOV AX,[SI]
PUSH AX
MOV AX,[SI+2]
PUSH AX
MOV AX,[SI+4]
PUSH AX
MOV AX,[SI+6]
PUSH AX
CALL LINE
POP SI
ADD SI,8
POP CX
LOOP DDD
mov ah,0
int 16h
mov ax,mode;恢复原显示模式
int 10h
MOV AX,4C00H
INT 21H

;设置写模式
SET_WRITE_MODE:
PUSH AX
MOV DX,3CEH
MOV AL,5
OUT DX,AL
MOV DX,3CFH
POP AX
OUT DX,AL
MOV DX,3CEH
MOV AL,8
OUT DX,AL
MOV DX,3CFH
MOV AL,0FFH
OUT DX,AL
RET
;* * * 清屏 * * *
CLEAR:
MOV BX,0
CLR1: MOV ES:[BX],AL
INC BX
CMP BX,80*480
jb CLR1
RET
;计算线上各点坐标
LINE:
PUSH BP
MOV BP,SP
SUB SP,16
MOV WORD PTR[BP-6],0 ;X=0
MOV WORD PTR[BP-8],0 ;Y=0
MOV WORD PTR[BP-14],1 ;INCX=1
MOV WORD PTR[BP-16],1 ;INCY=1
MOV AX,WORD PTR[BP+6] ;AX<=X2
SUB AX,WORD PTR[BP+10] ;AX<=X2-X1
JNC L1 ;IF X2>=X1,JMP L1
NEG AX ;IF X2<X1,DELTA_X=-DELTA_X
MOV WORD PTR[BP-14],-1 ;INCX<=-1
L1: CMP AX,0 ;IF DELTA_X!=0,JMP L11
JNE L11 ;
MOV WORD PTR[BP-14],0 ;INCX<=0
L11: MOV WORD PTR[BP-10],AX ;DELTA_X<=AX SP-> | |
MOV AX,WORD PTR[BP+4] ;AX<=Y2 | INCY |
SUB AX,WORD PTR[BP+8] ;AX<=Y2-Y1 | INCX |<-BP-14
JNC L2 ;IF Y2>=Y1,JMP L2 | DELTA_Y|<-BP-12
NEG AX ;IF Y2<Y1,DELTA_Y=-DELTA_Y | DELTA_X|<-BP-10
MOV WORD PTR[BP-16],-1 ;INCY<=-1 | Y |<-BP-8
L2: CMP AX,0 ;IF DELTA_Y!=0,JMP L22 | X |<-BP-6
JNE L22 ; |DISTANCE|<-BP-4
MOV WORD PTR[BP-16],0 ;INCY<=0 | T |<-BP-2
L22: MOV WORD PTR[BP-12],AX ;DELTA_Y<=AX | BP |<-BP
LP4: MOV AX,WORD PTR[BP-10] ;AX<=DELTA_X |返回地址|<-BP+2
CMP AX,WORD PTR[BP-12] ; | Y2 |<-BP+4
JG LP5 ;DELTA_X>DELTA_Y | X2 |<-BP+6
MOV AX,WORD PTR[BP-12] ; | Y1 |<-BP+8
MOV WORD PTR[BP-4],AX ;DISTANCE<=DELTA_Y | X1 |<-BP+10
JMP LP51 ; | |
LP5: MOV AX,WORD PTR[BP-10] ; LINE堆栈结构
MOV WORD PTR[BP-4],AX ;DISTANCE<=DELTA_X
LP51: INC AX
MOV WORD PTR[BP-2],AX
LP6: PUSH WORD PTR[BP+10]
PUSH WORD PTR[BP+8]
PUSH COLOR
CALL PIXEL
MOV AX,WORD PTR[BP-6] ;AX<=X
ADD AX,WORD PTR[BP-10] ;AX<=X+DELTA_X
MOV WORD PTR[BP-6],AX ;X=X+DELTA_X
MOV AX,WORD PTR[BP-8] ;AX<=Y
ADD AX,WORD PTR[BP-12] ;AX<=Y+DELTA_Y
MOV WORD PTR[BP-8],AX ;Y=Y+DELTA_Y
MOV AX,WORD PTR[BP-6] ;AX<=X
CMP AX,WORD PTR[BP-4]
JLE LP7 ;IF X<=DISTANCE,JMP LP7
MOV AX,WORD PTR[BP-6] ;X>DISTANCE
SUB AX,WORD PTR[BP-4] ;AX<=X-DISTANCE
MOV WORD PTR[BP-6],AX ;X=X-DISTANCE
MOV AX,WORD PTR[BP+10] ;AX<=X1
ADD AX,WORD PTR[BP-14] ;AX<=X1+INCX
MOV WORD PTR[BP+10],AX ;X1=X1+INCX
LP7: MOV AX,WORD PTR[BP-8] ;AX<=Y
CMP AX,WORD PTR[BP-4]
JLE LP8 ;IF Y<=DISTANCE,JMP LP8
MOV AX,WORD PTR[BP-8] ;Y>DISTANCE
SUB AX,WORD PTR[BP-4] ;AX<=Y-DISTANCE
MOV WORD PTR[BP-8],AX ;Y=Y-DISTANCE
MOV AX,WORD PTR[BP+8] ;AX<=Y1
ADD AX,WORD PTR[BP-16] ;AX<=Y1+INCY
MOV WORD PTR[BP+8],AX ;Y1=Y1+INCY
LP8: DEC WORD PTR[BP-2] ;IF T!=0,JMP LP6
jnz LP6
LP9: MOV SP,BP
POP BP
RET 8
;* * * 画点 * * *
PIXEL:
PUSH BP
PUSH BX
PUSH CX
PUSH DS
MOV BP,SP
MOV AX,80
MOV BX,WORD PTR[BP+12] ;BX<=Y
MUL BX ;(DX:AX)<=80*Y
MOV BX,AX ;
MOV AX,WORD PTR[BP+14] ;AX<--X
MOV CL,8 ; | |
DIV CL ;AL<=商(X/8),AH<=余数(X%8) SP-> | |
MOV CL,AH ;CL<=AH | DS |<-BP
MOV AH,0 ; | CX |<-BP+2
ADD BX,AX ;BX(OFFSET)<=80*Y+X/8 | BX |<-BP+4
MOV AL,80H ; | BP |<-BP+6
SHR AL,CL ;AL(MASK)<=(80H>>CL) |返回地址|<-BP+8
PUSH AX ; | COLOR |<-BP+10
MOV DX,3CEH ; | Y |<-BP+12
MOV AL,8 ; | X |<-BP+14
OUT DX,AL ; | |
MOV DX,3CFH ; PIXEL堆栈结构
POP AX
OUT DX,AL
MOV AL,ES:[BX]
MOV AX,WORD PTR[BP+10] ;AX<=COLOR
MOV BYTE PTR ES:[BX],AL
POP DS
POP CX
POP BX
POP BP
RET 6

CODES ENDS
END START
